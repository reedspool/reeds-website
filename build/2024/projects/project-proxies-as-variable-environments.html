<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" >
    <meta itemprop="nocontainer" >
    <meta http-equiv="x-ua-compatible" content="ie=edge" >
    <title>
      Reed's Website
    </title>
    <link rel="manifest" href="/site.webmanifest" >
    <link rel="icon" href="/favicon.png" >
    <meta name="description" content="" >
    <meta name="viewport" content="width=device-width, initial-scale=1" >

    <link       rel="stylesheet"
      href="/system/global.css"
      type="text/css"
      media="screen"
    >
    <link rel="stylesheet" href="/site.css" type="text/css" media="screen" >
    <style>
      body {
        height: fit-content; /* Body height affects sticky header behavior */
        min-height: 100vh;
        display: grid;
        grid-template-rows: auto 1fr auto;
        width: 100%;
      }
    </style>
  </head>

  <body>
    <div class="sticky-top higher">
      <header>
        <center-column-layout>
          <nav aria-label="Main navigation">
            <ul>
              <li><a href="/">Home</a></li>
              <li><a href="/recent.html">Recent</a></li>

            </ul>
          </nav>
        </center-column-layout>
      </header>
      <center-column-layout class="relative lower">

      </center-column-layout>
    </div>
    <main>
      <center-column-layout>
        <h1>Project: Proxies as Variable Environments</h1>
<h2>Logbook</h2>
<h3>Wed Dec 27 10:08:45 PST 2023</h3>
<p>When I was writing small scripts, like the <a href="https://github.com/reedspool/reeds-website/blob/main/scripts/generate-new-post.tsx#L1">&quot;generate new post&quot; script</a> which I used to generate this page, I found I wanted more visibility into what my script was doing. Especially while developing or debugging, I wanted to see every time a variable changed. So I used a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy (MDN)</a> to make a special store for special variables which would print whenever they were retrieved or set.</p>
<pre><code>
// A proxy to store some special variables with some logging tools (off by default)
// Turn logging on by passing `{ level: Infinity }`
// Override the logger by passing in `{ log: MyLog }`. Defaults to `console.log`
// Level 0: Nothing printed
// Level 1: Sets are pretty-printed
// Level 2: Gets are also pretty-printed
// Level 3: Entire variable storage is pretty-printed JSONified after every Set
// Level 4: Ditto also before every Get
const createStore = ({ log = console.log, level = 0 } = {}) => {
return new Proxy(
{},
{
get(target, prop) {
level >= 4 &&
log?.(`Target is now: \${JSON.stringify(target, null, 2)}`);
level >= 2 &&
log?.(`Getting '\${prop.toString()}' value of '\${target[prop]}'`);
return target[prop];
},
set(target, prop, value) {
level >= 1 &&
log?.(`Setting '\${prop.toString()}' to '\${value}'`)
target[prop] = value;
level >= 3 &&
log?.(`Target is now: \${JSON.stringify(target, null, 2)}`)
}
}
)
}

window.createStore = createStore;
</code></pre>
<p><future->I added a way adjust the level and the logger after creation. I also considered a way to set the initial state of the target (where currently I was using a literal empty object); that way one could just create a brand new store with the old initial value, maybe? I had to think more about it.</future-></p>
<p><future->I added a demo on this page for this proxy store, where I created a special logger which appended to an HTML element, and then a small form to edit the proxy</future-></p>
<p>I also made a custom, functional logger which could be disabled.</p>
<pre><code>
// A logger with some additional tools to turn it on and off
// Override the internal logger by passing in `{ log: MyLog }`. Defaults to `console.log`
const createFunctionalLogger = ({ log = console.log } = {}) => {
  let state = 'on';
  return {
    on() { state = 'on' },
    off() { state = 'off' },
    toggle() { state === 'on' ? off() : on() },
    async preserveState(fn) {
      const previous = state;
      await fn();
      state = previous;
    },
    log(...args) {
      state === 'on' && log(...args);
    }
  }
}
window.createFunctionalLogger = createFunctionalLogger;
</code></pre>
<p>As a quick example of how to use these together, here's a transcript from a session with them both:</p>
<pre><code>const logger = createFunctionalLogger() // Will use `console.log`
store = createStore({ level: 2, log: logger.log })
store.value = 3 // Logs &quot;Setting 'value' to '3'&quot;
logger.off()
store.value = 6 // No log
logger.on()
store.value = 8 // Logs &quot;Setting 'value' to '8'&quot;
</code></pre>
<details open>      <summary>Backlinks</summary>      <ul>        <li>                    <a href="/index-verbose.html">More Stuff On This Site</a>                  </li>      </ul>    </details>
<details open>      <summary>Keywords</summary>      <ul>        No keywords      </ul>    </details>
      </center-column-layout>
    </main>
    <footer>
      <center-column-layout>
        <nav aria-label="Secondary navigation">
          <ul>
            <li><a href="/">Home</a></li>
            <li><a rel="me" href="/contact">Contact</a></li>
            <li><a href="/recent.html">Recent</a></li>
            <li><a href="/sitemap.html">Sitemap</a></li>
            <li><a href="#">Top of page â¤´</a></li>
          </ul>
        </nav>
      </center-column-layout>
    </footer>
  </body>
</html>
