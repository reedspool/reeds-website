<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" >
    <meta itemprop="nocontainer" >
    <meta http-equiv="x-ua-compatible" content="ie=edge" >
    <title>
      Reed's Website
    </title>
    <link rel="manifest" href="/site.webmanifest" >
    <link rel="icon" href="/favicon.png" >
    <meta name="description" content="" >
    <meta name="viewport" content="width=device-width, initial-scale=1" >

    <link       rel="stylesheet"
      href="/system/global.css"
      type="text/css"
      media="screen"
    >
    <link rel="stylesheet" href="/site.css" type="text/css" media="screen" >
    <style>
      body {
        height: fit-content; /* Body height affects sticky header behavior */
        min-height: 100vh;
        display: grid;
        grid-template-rows: auto 1fr auto;
        width: 100%;
      }
    </style>
  </head>

  <body>
    <div class="sticky-top higher">
      <header>
        <center-column-layout>
          <nav aria-label="Main navigation">
            <ul>
              <li><a href="/">Home</a></li>
              <li><a href="/recent.html">Recent</a></li>

            </ul>
          </nav>
        </center-column-layout>
      </header>
      <center-column-layout class="relative lower">

      </center-column-layout>
    </div>
    <main>
      <center-column-layout>
        <h1>Project: Playing with JavaScript's keyword</h1>
<h2>Logbook</h2>
<h3>Mon Jun 03 15:37:49 GMT-0700 (Pacific Daylight Time) 2024</h3>
<p>I had a silly idea about JavaScript's <code>new</code> keyword. You can return whatever you want from a JavaScript constructor. Could you return something different from a constructor when called normally versus with a <code>new</code> keyword? Yes! I found the wild <code>new.target</code> magic property. I say &quot;wild&quot; and &quot;magic&quot; because nothing else in JavaScript works like this. So anyways, what could we do with this magic property?</p>
<p>I had this question: &quot;could I make a function which can generate any number any integer with only a mix of <code>new</code> and parentheses?&quot; That is, if I only mixed the word <code>new</code> and the open and closing paren characters (<code>(</code> and <code>)</code>), could I generate an arbitrary expression which evaluates to an arbitrary integer (whole number)?</p>
<p>So I'd need a recursive constructor. That was simple enough.</p>
<pre><code>
{
  function Recurse() {
    return Recurse;
  }

  console.log(
    `Is Recurse recursive?`,
    new Recurse() === Recurse ? "Yes!" : "No")
}
</code></pre>
<p>And I'd need to differentiate between using the <code>new</code> keyword to call as a constructor or just parentheses to call as a normal function:</p>
<pre><code>
{
  function Differentiate() {
    if (new.target) {
      return { value: "A" }
    } else {
      return { value: "B" }
    }
  }

  console.log(
    `Differentiate detects \`new\`?`,
    (new Differentiate).value === "A" ? "Yes!" : "No")

  console.log(
    `Differentiate detects normal call?`,
    (Differentiate()).value === "B" ? "Yes!" : "No")
}
</code></pre>
<p>I also needed a function which was callable but when used in an expression would evaluate to a number. I found I could achieve this by editing the prototype's <code>valueOf</code>. I also learned with the help of <a href="https://stackoverflow.com/a/21807662">this stack overflow answer</a> that modifying the prototype of a function was possible but slow. Well, I wasn't here to win any speed benchmarks.</p>
<pre><code>
{
  const Prototype = { valueOf: function () { return this.value; } }
  function Hidden(value) {
    const callable = function () {
      this.value = value
    }
    Object.setPrototypeOf(callable, Prototype)
    callable.value = value;
    return callable;
  }

  console.log(
    `Does Hidden return a callable?`,
    typeof (new Hidden()) === "function" ? "Yes!" : "No")

  console.log(
    `Does Hidden return a number?`,
    (new Hidden(321)) + 222 === 543 ? "Yes!" : "No")
}
</code></pre>
<p>With that I felt I had all the tools I needed. I had only to mash them together in various arrangements until the perfect result arose.</p>
<pre><code>
{
  const Prototype = { valueOf: function () { return this.value; } }
  function newnew() {
    const newnewnew = function () {
      const newnewnewnew = arguments.callee

      Object.setPrototypeOf(newnewnewnew, Prototype)
      newnewnewnew.value = new.target ? arguments.callee * 2 : arguments.callee + 1;
      return newnewnewnew
    }
    newnewnew.value = new.target ? 0 : 1;
    Object.setPrototypeOf(newnewnew, Prototype)
    return newnewnew
  }

  console.log(
    `newnew's can make 0`,
    +(new newnew()) === 0 ? "Yes!" : "No")
  console.log(
    `newnew's can make 1`,
    +(newnew()) === 1 ? "Yes!" : "No")
  console.log(
    `newnew's can make 2`,
    +new (newnew()) === 2 ? "Yes!" : "No")
  console.log(
    `newnew's can make 3`,
    +new (newnew())()() === 3 ? "Yes!" : "No")
  console.log(
    `newnew's can make 18`,
    +(new new new new (newnew())()()())()() === 18 ? "Yes!" : "No")
}
</code></pre>
<p>Now, obviously, this is ridiculous. And I'm not even using the parameter to the function. What's the need for that?</p>
<p>Also, this is not any integer, since I have no way to make negative numbers. Maybe the parameter could negate the input?</p>
<h3>Wed Jun 5 12:40:00 AM PDT 2024</h3>
<p>All the code above worked when I tested it in Node locally, but when I pushed this webpage up, I found it failed in the browser:</p>
<pre><code>Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them
</code></pre>
<p>My fancy script tags defaulted to <code>&lt;script type=&quot;module&quot;&gt;</code>, and only through this incident did I learn that <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode#strict_mode_for_modules">modules automatically engage strict mode</a>. Interesting! Anyways, I simply switched them to non-module scripts and that seemed to work!</p>
<p>I figured I could also fix this by not using <code>arguments.callee</code>, since I already had a reference to the function name as a closure. But nobody uses <code>arguments.callee</code> anymore, so that added to the funkiness of the experiment.</p>
<details open>
      <summary>Backlinks</summary>
      <ul>
        <li>
                    <a href="/index-verbose.html">More Stuff On This Site</a>
                  </li>
      </ul>
    </details>
<details open>
      <summary>Keywords</summary>
      <ul>
        No keywords
      </ul>
    </details>
      </center-column-layout>
    </main>
    <footer>
      <center-column-layout>
        <nav aria-label="Secondary navigation">
          <ul>
            <li><a href="/">Home</a></li>
            <li><a rel="me" href="/contact">Contact</a></li>
            <li><a href="/recent.html">Recent</a></li>
            <li><a href="/sitemap.html">Sitemap</a></li>
            <li><a href="#">Top of page â¤´</a></li>
          </ul>
        </nav>
      </center-column-layout>
    </footer>
  </body>
</html>
